---
marp: true
math: mathjax
title: Raport z projektu
size: 16:9
paginate: true
transition: fade
backgroundImage: url("page-background.png")
footer: "**Raport SJU**"
style: |
  @import url('https://unpkg.com/tailwindcss@^2/dist/utilities.min.css');

  section {
    padding: 2rem 3rem;
  }

  ul {
    margin-left: 1.25rem;
  }

  .grid {
    gap: 1.5rem;
  }

  .grid > div {
    padding: 1rem;
    background-color: rgba(255 255 255 / 0.1);
    border-radius: 0.5rem;
  }

  .grid ul {
    padding-left: 1rem;
    list-style-type: disc;
  }

  .grid strong {
    display: block;
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
  }
---

## Etapy realizacji

# Etap 1: Przygotowanie środowiska
- Analiza wymagań i wybór narzędzi
- Utworzenie Dockerfile i devcontainer.json

---

# Etap 2: Budowa i konfiguracja obrazu Docker
- Instalacja niezbędnych pakietów i bibliotek w Dockerfile
- Testowanie instalacji i konfiguracji lokalnie w kontenerze
- Dodanie plików projektu i konfiguracji środowiska w devcontainer.json

---

# Etap 3: Automatyzacja CI/CD z GitHub Actions
- Stworzenie workflow do budowy i publikacji obrazu
- Testowanie i wypychanie obrazu do GHCR

---

# Etap 4: Przygotowanie raportu i dokumentacji
- Utworzenie katalogu `doc` w repozytorium
- Stworzenie pliku Markdown z prezentacją MARP według szablonu
- Dodanie szczegółów konfiguracji, diagramów i podsumowania
- Eksport raportu do HTML i PDF

---

# Etap 5: Publikacja raportu
- Aktywacja GitHub Pages z konfiguracją publikacji z katalogu `doc`
- Weryfikacja dostępności opublikowanej strony raportu
- Ostateczne przesłanie raportu i linku do publikacji na platformę PZE

---

# Konfiguracja Dockerfile i devcontainer

<div class="grid grid-cols-2 gap-6 items-start">
  <div class="col-span-1">
    <ul>
      <li><strong>Bazowy obraz:</strong> <code>python:3.12-bullseye</code></li>
      <li><strong>Instalacja pakietów:</strong>
        <ul>
          <li><code>ipykernel</code>, <code>jupyter</code>, <code>qiskit</code>, <code>matplotlib</code>, <code>pillow</code>, <code>pycryptodomex</code>, <code>cryptography</code></li>
        </ul>
      </li>
      <li>Utworzenie użytkownika <code>vscode</code> z domyślnym katalogiem roboczym</li>
      <li>Montowanie katalogu roboczego (<code>workspace</code>) z hosta do kontenera</li>
      <li>Użycie <code>pip install --no-cache-dir -r requirements.txt</code> do instalacji zależności</li>
    </ul>
  </div>

  <div class="col-span-1">
    <ul>
      <li><strong>Plik <code>devcontainer.json</code>:</strong>
        <ul>
          <li>Definicja obrazu: <code>ghcr.io/adamo-sv/projekt_sju:latest</code></li>
          <li>Montowanie repozytorium do <code>/home/vscode/workspace</code></li>
          <li>Ustawienie użytkownika zdalnego: <code>vscode</code></li>
          <li><strong>PostCreateCommand:</strong> test środowiska po instalacji pakietów</li>
        </ul>
      </li>
      <li><strong>Rozszerzenia VSCode:</strong>
        <ul>
          <li><code>ms-python.python</code></li>
          <li><code>ms-toolsai.jupyter</code></li>
        </ul>
      </li>
      <li>Integracja z GitHub Codespaces i CLI <code>devcontainers</code></li>
      <li>Możliwość lokalnego i zdalnego debugowania</li>
    </ul>
  </div>
</div>

---

# Budowa i publikacja obrazu Dockera

- **Trigger:** workflow uruchamiany ręcznie (`workflow_dispatch`) oraz automatycznie po wypchnięciu taga `v*.*.*`
- **Środowisko:** `ubuntu-latest`
- **Kroki:**
  - `checkout`: pobranie kodu źródłowego z repozytorium
  - `setup-buildx`: konfiguracja buildera Docker Buildx
  - `login-action`: logowanie do GitHub Container Registry
- **Budowanie i testowanie:**
  - `docker build` tworzy obraz `sjuprojekt`
  - kopiowanie testów do kontenera i ich uruchomienie przez `docker run`
- **Publikacja:**
  - tagowanie obrazu jako `ghcr.io/adamo-sv/projekt_sju`
  - wypchnięcie do GitHub Container Registry

---

## Diagram przepływu pracy (Mermaid)

```mermaid
graph TD;
  A[Start] --> B{Decyzja};
  B -->|Tak| C[Akcja 1];
  B -->|Nie| D[Akcja 2];
  C --> E[Koniec];
  D --> E[Koniec];
